# https://www.tutorialspoint.com/gitlab/gitlab_ci_cd_variables.htm

stages:
  - build
  - test # only starts when the build completes successfully
  - deploy # only start when the tests are completed successfully

workflow:
  rules:
    # configure the entire pipeline to run in merge request pipelines
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'

build-job:
  stage: build
  image: docker
  services: 
  # docker in docker (dind)
    - docker:dind
  script:
    # login with user / password
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin
    #  "-t" to allocate a virtual terminal session within the container, build an image
    - docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG" .
    # push an image to container registry (project name / branch)
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
#  only:
#    # run in merge request pipelines
#    - merge_requests

unit-test-job:
  stage: test
  # pull the built image
  image: "$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
  script:
    - poetry run pytest
    - echo "Doing some testing"
#  only:
#    # run in merge request pipelines
#    - merge_requests

lint-test-job:
  stage: test
  image: "$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
  script:
    - poetry run flake8
    - echo "Doing some linting"
  # Let the pipeline continue running subsequent jobs, even if the job fails
  allow_failure: true
#  only:
#    # run in merge request pipelines
#    - merge_requests

deploy-job:
  stage: deploy
  image: "$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
  script:
    - echo "Doing some deployment"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH
      when: never